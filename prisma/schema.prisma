// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String           @id @default(cuid())
  email           String           @unique
  name            String?
  photoUrl        String?
  googleId        String?          @unique
  role            String           @default("user") // super_admin, admin, user
  isActive        Boolean          @default(true)
  lastLoginAt     DateTime?
  employeeId      String?          @unique // Liaison avec un employé
  employee        Employee?        @relation(fields: [employeeId], references: [id])
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  sessions        Session[]
  invitations     Invitation[]     @relation("InvitedBy")
  access          UserAccess?
  menuPermissions MenuPermission[]

  @@index([googleId])
  @@index([email])
  @@index([employeeId])
}

model Session {
  id        String   @id @default(cuid())
  userId    String
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  token     String   @unique
  expiresAt DateTime
  userAgent String?  @db.Text
  ipAddress String?
  createdAt DateTime @default(now())

  @@index([userId])
  @@index([token])
  @@index([expiresAt])
}

model Opportunity {
  id               String    @id @default(cuid())
  name             String
  value            Float?
  company          String?
  referredBy       String?
  leadSourceType   String?
  contact          String?
  contactId        String?
  linkedContact    Contact?  @relation(fields: [contactId], references: [id])
  completedAt      DateTime?
  stage            String    @default("00 - Idées de contact")
  proposal         String?   @db.Text
  assignee         String?
  closedDate       DateTime?
  openDate         DateTime?
  region           String?
  segment          String?
  proposalSentDate DateTime?
  projectType      String?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([stage])
  @@index([region])
  @@index([segment])
  @@index([contactId])
}

model Contact {
  id                  String    @id @default(cuid())
  fullName            String
  firstName           String?
  lastName            String?
  level               Int?
  potentialSale       Boolean   @default(false)
  photoUrl            String?
  linkedinUrl         String?
  position            String?
  company             String?
  email               String?
  phone               String?
  relation            String?
  circles             String?
  employmentField     String?
  lastUpdated         DateTime?
  region              String?
  birthday            String?
  link                String?
  tags                String?
  linkedOpportunities String?
  projects            String?
  language            String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  opportunities  Opportunity[]
  linkedProjects Project[]

  @@index([region])
  @@index([employmentField])
  @@index([company])
}

model Project {
  id            String   @id @default(cuid())
  name          String
  client        String?
  team          String?
  status        String?
  stage         String?
  billing       String?
  lead          String?
  clientComm    String?
  contactName   String?
  contactMethod String?
  hourlyRate    Float?
  proposalUrl   String?
  budget        String?
  driveUrl      String?
  asanaUrl      String?
  slackUrl      String?
  timeline      String?
  projectType   String?
  year          String?
  description   String?  @db.Text
  brief         String?  @db.Text
  testimonial   String?
  portfolio     String?
  report        String?
  communication String?
  departments   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Relations
  companyId String?
  company   Company? @relation(fields: [companyId], references: [id])
  contactId String?
  contact   Contact? @relation(fields: [contactId], references: [id])

  tasks      Task[]
  milestones Milestone[]

  @@index([status])
  @@index([projectType])
  @@index([client])
  @@index([year])
  @@index([companyId])
  @@index([contactId])
}

model Company {
  id               String   @id @default(cuid())
  name             String
  logoUrl          String?
  website          String?
  address          String?
  phone            String?
  type             String?
  mainContactName  String?
  mainContactEmail String?
  description      String?  @db.Text
  industry         String?
  insight          String?  @db.Text
  engagements      String?  @db.Text
  linkedinUrl      String?
  facebookUrl      String?
  instagramUrl     String?
  agencyPartners   String?
  referralPartners String?
  isClient         Boolean  @default(false)
  testimonials     String?
  events           String?
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  projects  Project[]
  contracts Contract[]

  @@index([type])
  @@index([industry])
  @@index([isClient])
}

// Departments: Lab, Bureau, Studio
model Employee {
  id                    String    @id @default(cuid())
  name                  String
  email                 String?
  phone                 String?
  birthDate             DateTime? // Date d'anniversaire
  photoUrl              String?
  linkedinUrl           String?
  role                  String?
  department            String // Lab, Bureau, Studio
  capacityHoursPerWeek  Int       @default(35) // Capacité en heures par semaine
  currentTaskId         String?   @unique // Only one current task per employee
  currentTask           Task?     @relation("CurrentTask", fields: [currentTaskId], references: [id])
  onboardingCompleted   Boolean   @default(false)
  onboardingStartedAt   DateTime?
  onboardingCompletedAt DateTime?
  googleCalendarId      String? // ID du calendrier Google (email ou ID)
  googleCalendarSync    Boolean   @default(false) // Activer la sync
  googleAccessToken     String?   @db.Text // OAuth access token
  googleRefreshToken    String?   @db.Text // OAuth refresh token
  googleTokenExpiry     DateTime? // Expiration du token
  createdAt             DateTime  @default(now())
  updatedAt             DateTime  @updatedAt

  // Relations onboarding
  onboardingProgress    OnboardingProgress[]
  policyAcknowledgments PolicyAcknowledgment[]
  chatMessages          ChatMessage[]

  // Relations portail employé
  portal    EmployeePortal?
  requests  EmployeeRequest[]
  documents EmployeeDocument[]
  events    EmployeeEvent[]

  // Relations accès et contexte Leo
  access     EmployeeAccess?
  leoContext EmployeeLeoContext?

  // Relation avec l'utilisateur connecté
  linkedUser User?

  // Relations vacances
  vacationRequests VacationRequest[]
  vacationBalance  VacationBalance?

  // Relations recommandations et sondages
  recommendations Recommendation[]
  surveyResponses SurveyResponse[]

  // Relations tâches personnelles
  personalTasks PersonalTask[]

  @@index([department])
}

// Task zones: current, shelf, storage, dock
// Task status: todo, in_progress, done
model Task {
  id               String    @id @default(cuid())
  title            String
  description      String?   @db.Text
  zone             String    @default("shelf") // current, shelf, storage, dock
  department       String    @default("Lab") // Lab, Bureau, Studio
  status           String    @default("todo") // todo, in_progress, done
  projectId        String?
  project          Project?  @relation(fields: [projectId], references: [id])
  priority         String?   @default("medium") // low, medium, high
  estimatedHours   Float?    @default(2) // Heures estimées pour la tâche
  dueDate          DateTime?
  completedAt      DateTime?
  order            Int       @default(0)
  googleEventId    String? // ID de l'événement Google Calendar
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  assignedEmployee Employee? @relation("CurrentTask")

  @@index([zone])
  @@index([department])
  @@index([projectId])
  @@index([status])
}

// Events and Calendar
model Event {
  id          String    @id @default(cuid())
  title       String
  description String?   @db.Text
  type        String    @default("meeting") // meeting, deadline, reminder, call, other
  startDate   DateTime
  endDate     DateTime?
  allDay      Boolean   @default(false)
  location    String?
  color       String?   @default("#6366f1")

  // Linked entities
  contactId     String?
  opportunityId String?
  projectId     String?
  companyId     String?

  // Reminders
  reminder     Boolean @default(false)
  reminderTime Int? // minutes before event

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([startDate])
  @@index([type])
  @@index([contactId])
  @@index([opportunityId])
  @@index([projectId])
}

// Documents attachés aux entités
model Document {
  id          String  @id @default(cuid())
  name        String
  url         String?
  type        String? // file, link, drive, figma, notion, github, pdf, doc, xls, image, etc.
  size        Int? // taille en bytes
  fileKey     String? // Clé S3 pour les fichiers uploadés
  mimeType    String? // Type MIME pour les fichiers
  description String? @db.Text
  category    String? // design, dev, docs, contracts, assets, general, etc.

  // Entité liée (une seule à la fois)
  companyId     String?
  contactId     String?
  projectId     String?
  opportunityId String?

  uploadedBy String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  taskDocuments TaskDocument[]

  @@index([companyId])
  @@index([contactId])
  @@index([projectId])
  @@index([opportunityId])
  @@index([type])
  @@index([category])
}

// Historique des activités
model ActivityLog {
  id          String   @id @default(cuid())
  action      String // created, updated, status_changed, note_added, document_uploaded, etc.
  description String?
  entityType  String // contact, company, project, opportunity
  entityId    String
  oldValue    String?  @db.Text
  newValue    String?  @db.Text
  userId      String?
  userName    String?
  createdAt   DateTime @default(now())

  @@index([entityType, entityId])
  @@index([createdAt])
}

// Milestones (grandes tâches de projet)
model Milestone {
  id           String    @id @default(cuid())
  title        String
  description  String?   @db.Text
  status       String    @default("pending") // pending, in_progress, completed
  startDate    DateTime?
  dueDate      DateTime?
  completedAt  DateTime?
  progress     Int       @default(0) // 0-100 percentage
  deliverables String?   @db.Text // JSON array of deliverables
  order        Int       @default(0)
  projectId    String
  project      Project   @relation(fields: [projectId], references: [id], onDelete: Cascade)
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@index([projectId])
  @@index([status])
  @@index([dueDate])
}

// Notes et commentaires
model Note {
  id         String   @id @default(cuid())
  content    String   @db.Text
  entityType String // contact, company, project, opportunity
  entityId   String
  authorName String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([entityType, entityId])
}

// Témoignages clients
model Testimonial {
  id          String   @id @default(cuid())
  clientName  String
  contactName String?
  companyName String?
  status      String   @default("received") // received, requested, online, pending
  textFr      String?  @db.Text
  textEn      String?  @db.Text
  titleFr     String?
  titleEn     String?
  rating      Int?     @default(5)
  featured    Boolean  @default(false)
  companyId   String?
  contactId   String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([status])
  @@index([featured])
}

// Phases de projet pour la transformation numérique
model ProjectPhase {
  id              String    @id @default(cuid())
  projectId       String
  phaseTemplateId String // diagnostic, strategie, design, developpement, ia, formation, deploiement, suivi
  name            String
  description     String?
  status          String    @default("pending") // pending, in_progress, completed, skipped
  progress        Int       @default(0) // 0-100
  order           Int       @default(0)
  startDate       DateTime?
  endDate         DateTime?
  estimatedHours  Int?
  actualHours     Int?
  hourlyRate      Float?    @default(150)
  notes           String?   @db.Text
  deliverables    String?   @db.Text // JSON array of deliverables
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  @@index([projectId])
  @@index([status])
}

// Devis générés
model Quote {
  id            String    @id @default(cuid())
  projectId     String?
  clientName    String
  clientEmail   String?
  clientCompany String?
  title         String
  description   String?   @db.Text
  status        String    @default("draft") // draft, sent, accepted, rejected, expired
  validUntil    DateTime?
  subtotal      Float     @default(0)
  taxRate       Float     @default(0.15) // 15% TPS+TVQ
  taxAmount     Float     @default(0)
  total         Float     @default(0)
  currency      String    @default("CAD")
  phases        String?   @db.Text // JSON array of selected phases with pricing
  notes         String?   @db.Text
  terms         String?   @db.Text
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([projectId])
  @@index([status])
}

// Entrées de temps pour le time tracking
model TimeEntry {
  id          String           @id @default(cuid())
  employeeId  String
  taskId      String?
  projectId   String?
  description String?
  startTime   DateTime
  endTime     DateTime?
  duration    Int? // Durée en minutes
  billable    Boolean          @default(true)
  status      String           @default("running") // running, completed, paused
  notes       String?          @db.Text
  timesheetId String? // Lien vers la feuille de temps hebdomadaire
  timesheet   WeeklyTimesheet? @relation(fields: [timesheetId], references: [id])
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  @@index([employeeId])
  @@index([taskId])
  @@index([projectId])
  @@index([startTime])
  @@index([timesheetId])
}

// Feuille de temps hebdomadaire avec approbation
model WeeklyTimesheet {
  id              String    @id @default(cuid())
  employeeId      String
  weekStartDate   DateTime // Lundi de la semaine (date sans heure)
  weekEndDate     DateTime // Dimanche de la semaine
  totalHours      Float     @default(0) // Total des heures de la semaine
  status          String    @default("draft") // draft, submitted, approved, rejected
  submittedAt     DateTime?
  approvedAt      DateTime?
  approvedBy      String? // ID de l'admin qui a approuvé
  approverName    String? // Nom de l'admin qui a approuvé
  rejectedAt      DateTime?
  rejectedBy      String?
  rejectionReason String?   @db.Text
  notes           String?   @db.Text // Notes de l'employé
  adminNotes      String?   @db.Text // Notes de l'admin
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  entries TimeEntry[]

  @@unique([employeeId, weekStartDate])
  @@index([employeeId])
  @@index([weekStartDate])
  @@index([status])
}

// ============================================
// HUB COMMUNICATION NUMÉRIQUE
// ============================================

// Catégories de clients (maintenance, comm, web, etc.)
model ClientCategory {
  id          String   @id @default(cuid())
  name        String   @unique
  color       String   @default("#6366f1") // Couleur pour l'affichage
  icon        String? // Icône optionnelle (nom lucide-react)
  description String?
  order       Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  clients CommunicationClient[]

  @@index([order])
}

// Client de communication (lié à un projet existant ou standalone)
model CommunicationClient {
  id               String                         @id @default(cuid())
  name             String
  company          String?
  email            String?
  phone            String?
  website          String?
  logoUrl          String?
  industry         String?
  description      String?                        @db.Text
  status           String                         @default("active") // active, paused, completed
  projectId        String? // Lien optionnel vers un projet existant
  companyId        String? // Lien vers une entreprise cliente (Company)
  categoryId       String? // Catégorie du client
  category         ClientCategory?                @relation(fields: [categoryId], references: [id])
  startDate        DateTime?
  monthlyBudget    Int? // Budget mensuel en dollars
  notes            String?                        @db.Text
  createdAt        DateTime                       @default(now())
  updatedAt        DateTime                       @updatedAt
  // Relations
  socialAccounts   SocialMediaAccount[]
  newsletters      Newsletter[]
  campaigns        Campaign[]
  accesses         ClientAccess[]
  messages         ClientMessage[]
  tasks            ClientTask[]
  // Hub de Communication - Agence du Futur
  contentCalendar  ContentCalendar[]
  briefs           CommunicationBrief[]
  strategies       CommunicationStrategy[]
  brandAssets      BrandAsset[]
  reports          CommunicationReport[]
  contentIdeas     ContentIdea[]
  contextDocuments CommunicationContextDocument[]

  @@index([status])
  @@index([projectId])
  @@index([companyId])
  @@index([categoryId])
}

// Comptes de médias sociaux
model SocialMediaAccount {
  id             String    @id @default(cuid())
  clientId       String
  platform       String // facebook, instagram, linkedin, twitter, tiktok, youtube, etc.
  accountName    String
  accountUrl     String?
  username       String?
  followers      Int?
  status         String    @default("active") // active, paused, archived
  accessEmail    String?
  accessPassword String? // Encrypted in production
  notes          String?   @db.Text
  lastPostDate   DateTime?
  postsPerWeek   Int?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([platform])
}

// Infolettres
model Newsletter {
  id             String    @id @default(cuid())
  clientId       String
  name           String
  platform       String? // mailchimp, sendinblue, hubspot, etc.
  listSize       Int? // Nombre d'abonnés
  frequency      String? // weekly, biweekly, monthly
  lastSentDate   DateTime?
  nextSendDate   DateTime?
  openRate       Float? // Taux d'ouverture moyen
  clickRate      Float? // Taux de clic moyen
  status         String    @default("active")
  templateUrl    String?
  accessEmail    String?
  accessPassword String?
  notes          String?   @db.Text
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
}

// Campagnes numériques (pub, SEO, etc.)
model Campaign {
  id             String    @id @default(cuid())
  clientId       String
  name           String
  type           String // google_ads, facebook_ads, linkedin_ads, seo, email, influencer
  status         String    @default("draft") // draft, active, paused, completed
  startDate      DateTime?
  endDate        DateTime?
  budget         Int?
  spent          Int?
  impressions    Int?
  clicks         Int?
  conversions    Int?
  revenue        Int?
  targetAudience String?   @db.Text
  objectives     String?   @db.Text
  notes          String?   @db.Text
  platformUrl    String? // Lien vers la plateforme de gestion
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([type])
  @@index([status])
}

// Accès et liens clients (sites, outils, etc.)
model ClientAccess {
  id         String    @id @default(cuid())
  clientId   String
  name       String // Nom du service/outil
  type       String // website, hosting, domain, analytics, cms, crm, email, other
  url        String?
  username   String?
  password   String? // Encrypted in production
  email      String?
  apiKey     String?
  expiryDate DateTime?
  notes      String?   @db.Text
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([type])
}

// Messages/Communications avec le client
model ClientMessage {
  id           String    @id @default(cuid())
  clientId     String
  direction    String // inbound, outbound
  channel      String // email, phone, meeting, slack, other
  subject      String?
  content      String    @db.Text
  attachments  String?   @db.Text // JSON array of attachment URLs
  sentAt       DateTime  @default(now())
  sentBy       String? // Employee ID or name
  isImportant  Boolean   @default(false)
  followUpDate DateTime?
  status       String    @default("sent") // sent, read, replied, archived
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([sentAt])
}

// Tâches spécifiques au client
model ClientTask {
  id             String    @id @default(cuid())
  clientId       String
  title          String
  description    String?   @db.Text
  type           String? // content, design, development, meeting, review, other
  status         String    @default("todo") // todo, in_progress, review, done
  priority       String    @default("medium") // low, medium, high, urgent
  dueDate        DateTime?
  assignedTo     String? // Employee ID
  estimatedHours Int?
  actualHours    Int?
  completedAt    DateTime?
  notes          String?   @db.Text
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  client CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([status])
  @@index([dueDate])
}

// ==================== ONBOARDING ====================

model OnboardingStep {
  id          Int      @id @default(autoincrement())
  title       String
  description String   @db.Text
  content     String   @db.Text
  type        String   @default("info") // info, video, quiz, policy, tour
  order       Int
  role        String? // null = all roles, or specific role (Lab, Bureau, Studio, Admin)
  isRequired  Boolean  @default(true)
  duration    Int      @default(5) // estimated minutes
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  progress OnboardingProgress[]
}

model Policy {
  id          Int      @id @default(autoincrement())
  title       String
  content     String   @db.Text
  category    String // general, security, hr, conduct, remote
  version     String   @default("1.0")
  isActive    Boolean  @default(true)
  requiresAck Boolean  @default(true) // requires acknowledgment
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  acknowledgments PolicyAcknowledgment[]
}

model PolicyAcknowledgment {
  id             Int      @id @default(autoincrement())
  employeeId     String
  policyId       Int
  acknowledgedAt DateTime @default(now())
  ipAddress      String?

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  policy   Policy   @relation(fields: [policyId], references: [id], onDelete: Cascade)

  @@unique([employeeId, policyId])
}

model OnboardingProgress {
  id          Int       @id @default(autoincrement())
  employeeId  String
  stepId      Int
  status      String    @default("pending") // pending, in_progress, completed, skipped
  completedAt DateTime?
  score       Int? // for quiz steps

  employee Employee       @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  step     OnboardingStep @relation(fields: [stepId], references: [id], onDelete: Cascade)

  @@unique([employeeId, stepId])
}

// Chat AI conversation history
model ChatMessage {
  id         Int      @id @default(autoincrement())
  employeeId String
  role       String // user, assistant
  content    String   @db.Text
  createdAt  DateTime @default(now())

  employee Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  @@index([employeeId])
}

// Relation entre documents et tâches
model TaskDocument {
  id         String   @id @default(cuid())
  taskId     String
  documentId String
  addedBy    String? // ID de l'employé qui a attaché le document
  createdAt  DateTime @default(now())

  document Document @relation(fields: [documentId], references: [id], onDelete: Cascade)

  @@unique([taskId, documentId])
  @@index([taskId])
  @@index([documentId])
}

// ============================================
// SYSTÈME DE TICKETS & PORTAIL CLIENT
// ============================================

// Portail Client - URL unique pour chaque client
model ClientPortal {
  id              String           @id @default(cuid())
  token           String           @unique @default(cuid())
  clientName      String
  clientEmail     String?
  companyId       String?
  isActive        Boolean          @default(true)
  welcomeMessage  String?          @db.Text
  expiresAt       DateTime? // Date d'expiration du token (null = jamais)
  lastUsedAt      DateTime? // Dernière utilisation du portail
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  tickets         Ticket[]
  recommendations Recommendation[]
  meetings        ClientMeeting[]

  @@index([token])
  @@index([companyId])
}

// Tickets soumis par les clients
model Ticket {
  id             String           @id @default(cuid())
  portalId       String
  portal         ClientPortal     @relation(fields: [portalId], references: [id], onDelete: Cascade)
  projectId      String?
  subject        String
  description    String           @db.Text
  category       String? // bug, feature, question, support
  priority       String           @default("medium") // low, medium, high, urgent
  status         String           @default("open") // open, in_progress, waiting, resolved, closed
  submittedBy    String? // Nom du soumetteur
  submittedEmail String? // Email du soumetteur
  assignedToId   String?
  resolvedAt     DateTime?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt
  responses      TicketResponse[]

  @@index([portalId])
  @@index([projectId])
  @@index([status])
  @@index([priority])
}

// Réponses aux tickets
model TicketResponse {
  id         String   @id @default(cuid())
  ticketId   String
  ticket     Ticket   @relation(fields: [ticketId], references: [id], onDelete: Cascade)
  content    String   @db.Text
  isInternal Boolean  @default(false) // Note interne ou réponse visible au client
  authorType String // client, employee
  authorName String?
  authorId   String? // employeeId si authorType = employee
  createdAt  DateTime @default(now())

  @@index([ticketId])
}

// Paramètres système
model SystemSettings {
  id          String   @id @default(cuid())
  key         String   @unique
  value       String   @db.Text
  description String?
  category    String? // general, email, notifications, security, etc.
  updatedAt   DateTime @updatedAt
  updatedBy   String?

  @@index([category])
}

// Portail Employé - Token d'accès unique
model EmployeePortal {
  id         String    @id @default(cuid())
  employeeId String    @unique
  employee   Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  token      String    @unique @default(cuid())
  isActive   Boolean   @default(true)
  expiresAt  DateTime? // Date d'expiration du token (null = jamais)
  lastAccess DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([token])
}

// Demandes des employés (congés, formations, équipement)
model EmployeeRequest {
  id          String    @id @default(cuid())
  employeeId  String
  employee    Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  type        String // leave, training, equipment, other
  title       String
  description String?   @db.Text
  startDate   DateTime?
  endDate     DateTime?
  status      String    @default("pending") // pending, approved, rejected
  priority    String    @default("normal") // low, normal, high, urgent
  reviewedBy  String?
  reviewedAt  DateTime?
  reviewNotes String?   @db.Text
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([employeeId])
  @@index([status])
  @@index([type])
}

// Documents des employés
model EmployeeDocument {
  id          String   @id @default(cuid())
  employeeId  String
  employee    Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  name        String
  description String?
  fileUrl     String
  fileType    String? // pdf, doc, image, etc.
  fileSize    Int? // en bytes
  category    String? // contract, payslip, training, personal, etc.
  isPrivate   Boolean  @default(true)
  uploadedBy  String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([employeeId])
  @@index([category])
}

// Événements du calendrier employé
model EmployeeEvent {
  id               String    @id @default(cuid())
  employeeId       String
  employee         Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  title            String
  description      String?   @db.Text
  startDate        DateTime
  endDate          DateTime?
  allDay           Boolean   @default(false)
  type             String    @default("event") // event, meeting, deadline, reminder
  location         String?
  color            String?
  isRecurring      Boolean   @default(false)
  recurringPattern String? // daily, weekly, monthly
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  @@index([employeeId])
  @@index([startDate])
}

// Accès employé aux clients et projets
model EmployeeAccess {
  id         String   @id @default(cuid())
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  // Type d'accès: "all" = tout, "selected" = sélection spécifique
  accessType String @default("all") // all, selected

  // Accès aux clients (companyIds séparés par virgule, ou "*" pour tous)
  clientAccess String? @db.Text

  // Accès aux projets (projectIds séparés par virgule, ou "*" pour tous)
  projectAccess String? @db.Text

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([employeeId])
  @@index([employeeId])
}

// Configuration du contexte Leo IA par employé
model EmployeeLeoContext {
  id         String   @id @default(cuid())
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  // Contextes activés pour Leo
  canAccessTasks         Boolean @default(true) // Accès aux tâches assignées
  canAccessProjects      Boolean @default(true) // Accès aux projets
  canAccessClients       Boolean @default(false) // Accès aux informations clients
  canAccessContacts      Boolean @default(false) // Accès aux contacts
  canAccessFinancials    Boolean @default(false) // Accès aux données financières (factures, devis)
  canAccessTeam          Boolean @default(false) // Accès aux infos équipe
  canAccessOpportunities Boolean @default(false) // Accès au pipeline commercial

  // Instructions personnalisées pour Leo
  customInstructions String? @db.Text

  // Restrictions
  restrictedTopics String? @db.Text // Sujets interdits (séparés par virgule)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([employeeId])
  @@index([employeeId])
}

// Notifications pour les employés
model EmployeeNotification {
  id         String    @id @default(cuid())
  employeeId String
  type       String // timesheet_approved, timesheet_rejected, task_assigned, task_updated, request_approved, request_rejected, general
  title      String
  message    String    @db.Text
  link       String? // Lien vers la ressource concernée (ex: /timesheets, /tasks/123)
  isRead     Boolean   @default(false)
  readAt     DateTime?
  metadata   String?   @db.Text // JSON avec données additionnelles
  createdAt  DateTime  @default(now())

  @@index([employeeId])
  @@index([isRead])
  @@index([createdAt])
}

// Invitations pour les nouveaux utilisateurs
model Invitation {
  id         String    @id @default(cuid())
  email      String
  token      String    @unique
  role       String    @default("user") // super_admin, admin, user
  invitedBy  String // ID de l'utilisateur qui a envoyé l'invitation
  expiresAt  DateTime
  acceptedAt DateTime?
  createdAt  DateTime  @default(now())

  inviter User @relation("InvitedBy", fields: [invitedBy], references: [id])

  @@index([email])
  @@index([token])
  @@index([expiresAt])
}

// Accès granulaires par utilisateur
model UserAccess {
  id     String @id @default(cuid())
  userId String

  // Type d'accès: all (tout), specific (sélection spécifique), none (aucun)
  clientsAccess  String @default("all") // all, specific, none
  projectsAccess String @default("all") // all, specific, none
  spacesAccess   String @default("all") // all, specific, none

  // IDs spécifiques si access = "specific" (JSON array)
  allowedClients  String? @db.Text // JSON array of client IDs
  allowedProjects String? @db.Text // JSON array of project IDs
  allowedSpaces   String? @db.Text // JSON array of space names (commercial, teams, billing, etc.)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId])
  @@index([userId])
}

// Préférences de notifications pour les employés
model NotificationPreferences {
  id         String @id @default(cuid())
  employeeId String @unique

  // Notifications par type
  timesheetApproved    Boolean @default(true)
  timesheetRejected    Boolean @default(true)
  taskAssigned         Boolean @default(true)
  taskUpdated          Boolean @default(true)
  requestApproved      Boolean @default(true)
  requestRejected      Boolean @default(true)
  generalAnnouncements Boolean @default(true)

  // Méthodes de notification
  inAppEnabled Boolean @default(true)
  emailEnabled Boolean @default(false)

  // Fréquence des emails (si activé)
  emailFrequency String @default("instant") // instant, daily, weekly

  // Heures de silence (ne pas envoyer de notifications)
  quietHoursEnabled Boolean @default(false)
  quietHoursStart   String? // Format HH:MM
  quietHoursEnd     String? // Format HH:MM

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employeeId])
}

// ==========================================
// HUB DE COMMUNICATION - AGENCE DU FUTUR
// ==========================================

// Calendrier éditorial - Publications planifiées
model ContentCalendar {
  id            String              @id @default(cuid())
  clientId      String
  title         String
  description   String?             @db.Text
  contentType   String // post, story, reel, article, newsletter, video, podcast, infographic
  platform      String // instagram, facebook, linkedin, twitter, tiktok, youtube, blog, newsletter
  status        String              @default("draft") // draft, scheduled, published, cancelled
  scheduledDate DateTime
  publishedDate DateTime?
  content       String?             @db.Text // Contenu du post
  mediaUrls     String?             @db.Text // URLs des médias (JSON array)
  hashtags      String?             @db.Text // Hashtags suggérés
  caption       String?             @db.Text // Légende/Caption
  link          String? // Lien associé
  assignedTo    String? // ID de l'employé assigné
  approvedBy    String? // ID de l'approbateur
  approvedAt    DateTime?
  engagement    String?             @db.Text // Métriques d'engagement (JSON)
  notes         String?             @db.Text
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  client        CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([scheduledDate])
  @@index([status])
  @@index([platform])
}

// Brief de projet de communication
model CommunicationBrief {
  id          String @id @default(cuid())
  clientId    String
  title       String
  projectType String // branding, campaign, social_media, website, video, event, launch
  status      String @default("draft") // draft, in_review, approved, in_progress, completed
  priority    String @default("medium") // low, medium, high, urgent

  // Contexte et objectifs
  background     String? @db.Text // Contexte du projet
  objectives     String? @db.Text // Objectifs SMART
  targetAudience String? @db.Text // Persona et audience cible
  keyMessages    String? @db.Text // Messages clés à communiquer
  toneOfVoice    String? // professional, friendly, bold, elegant, playful

  // Livrables et délais
  deliverables String?   @db.Text // Liste des livrables (JSON)
  startDate    DateTime?
  deadline     DateTime?
  milestones   String?   @db.Text // Jalons du projet (JSON)

  // Budget et ressources
  budget        Int?
  budgetDetails String? @db.Text // Répartition du budget (JSON)
  teamMembers   String? @db.Text // Membres de l'équipe assignés (JSON)

  // Références et inspiration
  competitors     String? @db.Text // Analyse concurrentielle
  inspiration     String? @db.Text // Références visuelles/créatives (JSON URLs)
  brandGuidelines String? // URL vers les guidelines de marque

  // Validation
  clientContact   String? // Contact principal côté client
  approvalProcess String? @db.Text // Processus de validation

  notes     String?             @db.Text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  client    CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([status])
  @@index([deadline])
}

// Stratégie de communication
model CommunicationStrategy {
  id       String  @id @default(cuid())
  clientId String
  title    String
  type     String // annual, quarterly, campaign, crisis, launch
  status   String  @default("draft") // draft, active, paused, completed
  period   String? // Q1 2024, 2024, etc.

  // Analyse
  swotAnalysis       String? @db.Text // Forces, Faiblesses, Opportunités, Menaces (JSON)
  competitorAnalysis String? @db.Text // Analyse concurrentielle (JSON)
  audienceInsights   String? @db.Text // Insights sur l'audience (JSON)

  // Objectifs stratégiques
  visionStatement String? @db.Text // Vision de la communication
  objectives      String? @db.Text // Objectifs stratégiques (JSON)
  kpis            String? @db.Text // KPIs à suivre (JSON)

  // Positionnement
  positioning      String? @db.Text // Positionnement de marque
  valueProposition String? @db.Text // Proposition de valeur
  brandPersonality String? @db.Text // Personnalité de marque

  // Canaux et tactiques
  channels       String? @db.Text // Canaux de communication (JSON)
  contentPillars String? @db.Text // Piliers de contenu (JSON)
  tacticalPlan   String? @db.Text // Plan tactique (JSON)

  // Budget et ressources
  budget           Int?
  budgetAllocation String? @db.Text // Répartition par canal (JSON)

  // Calendrier
  timeline String? @db.Text // Timeline stratégique (JSON)
  keyDates String? @db.Text // Dates clés (JSON)

  notes     String?             @db.Text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  client    CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([status])
  @@index([type])
}

// Assets de marque
model BrandAsset {
  id           String              @id @default(cuid())
  clientId     String
  name         String
  type         String // logo, color_palette, typography, icon, template, photo, video, document
  category     String? // primary, secondary, social, print, web
  fileUrl      String
  thumbnailUrl String?
  format       String? // png, jpg, svg, pdf, ai, psd, mp4
  dimensions   String? // 1920x1080, etc.
  fileSize     Int? // En bytes
  version      String? // v1, v2, etc.
  isApproved   Boolean             @default(false)
  approvedBy   String?
  approvedAt   DateTime?
  tags         String?             @db.Text // Tags pour recherche (JSON)
  usageNotes   String?             @db.Text // Notes d'utilisation
  createdAt    DateTime            @default(now())
  updatedAt    DateTime            @updatedAt
  client       CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([type])
  @@index([category])
}

// Rapports et Analytics
model CommunicationReport {
  id       String @id @default(cuid())
  clientId String
  title    String
  type     String // monthly, quarterly, annual, campaign, custom
  period   String // Janvier 2024, Q1 2024, etc.
  status   String @default("draft") // draft, sent, viewed

  // Métriques globales
  metrics    String? @db.Text // Toutes les métriques (JSON)
  highlights String? @db.Text // Points forts du mois (JSON)
  challenges String? @db.Text // Défis rencontrés (JSON)

  // Réseaux sociaux
  socialMetrics  String? @db.Text // Métriques par plateforme (JSON)
  topPosts       String? @db.Text // Meilleurs posts (JSON)
  audienceGrowth String? @db.Text // Croissance de l'audience (JSON)

  // Campagnes
  campaignResults String? @db.Text // Résultats des campagnes (JSON)

  // Recommandations
  recommendations String? @db.Text // Recommandations pour le prochain mois
  nextSteps       String? @db.Text // Prochaines étapes (JSON)

  // Fichier
  reportUrl       String? // URL du rapport PDF
  presentationUrl String? // URL de la présentation

  sentAt    DateTime?
  viewedAt  DateTime?
  notes     String?             @db.Text
  createdAt DateTime            @default(now())
  updatedAt DateTime            @updatedAt
  client    CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([type])
  @@index([period])
}

// Idées et brainstorming
model ContentIdea {
  id            String              @id @default(cuid())
  clientId      String
  title         String
  description   String?             @db.Text
  category      String? // trending, evergreen, seasonal, promotional, educational
  platform      String? // Pour quelle plateforme
  format        String? // post, video, story, carousel, etc.
  status        String              @default("idea") // idea, approved, scheduled, rejected
  priority      Int                 @default(0) // Score de priorité
  source        String? // Origine de l'idée (team, client, trend, competitor)
  references    String?             @db.Text // Liens de référence (JSON)
  suggestedDate DateTime?
  assignedTo    String?
  votes         Int                 @default(0) // Votes de l'équipe
  notes         String?             @db.Text
  createdAt     DateTime            @default(now())
  updatedAt     DateTime            @updatedAt
  client        CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  @@index([clientId])
  @@index([status])
  @@index([category])
}

// ==========================================
// PORTAIL CLIENT AMÉLIORÉ
// ==========================================

// Livrables de projet pour le client
model ClientDeliverable {
  id              String    @id @default(cuid())
  portalId        String
  projectId       String?
  title           String
  description     String?   @db.Text
  type            String // document, design, video, website, other
  status          String    @default("pending") // pending, in_review, approved, rejected, revision_requested
  dueDate         DateTime?
  fileUrl         String?
  thumbnailUrl    String?
  version         Int       @default(1)
  clientFeedback  String?   @db.Text
  approvedAt      DateTime?
  approvedBy      String?
  workflowEnabled Boolean   @default(false) // Activer le workflow d'approbation
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations pour workflow d'approbation
  workflow ApprovalWorkflow?
  versions DeliverableVersion[]

  @@index([portalId])
  @@index([projectId])
  @@index([status])
}

// Messagerie client-équipe
model ClientChatMessage {
  id          String   @id @default(cuid())
  portalId    String
  projectId   String?
  content     String   @db.Text
  senderType  String // client, employee
  senderName  String
  senderId    String? // employeeId si employee
  isRead      Boolean  @default(false)
  attachments String?  @db.Text // JSON array of file URLs
  createdAt   DateTime @default(now())

  @@index([portalId])
  @@index([projectId])
  @@index([createdAt])
}

// Notifications pour le client
model ClientNotification {
  id        String   @id @default(cuid())
  portalId  String
  type      String // deliverable_ready, message_received, meeting_scheduled, project_update, invoice_ready
  title     String
  message   String   @db.Text
  link      String?
  isRead    Boolean  @default(false)
  createdAt DateTime @default(now())

  @@index([portalId])
  @@index([isRead])
  @@index([createdAt])
}

// Fichiers partagés avec le client
model ClientFile {
  id           String   @id @default(cuid())
  portalId     String
  projectId    String?
  name         String
  description  String?
  fileUrl      String
  fileType     String // pdf, image, video, document, archive, other
  fileSize     Int? // en bytes
  category     String? // contract, invoice, deliverable, asset, brand, other
  uploadedBy   String // employee name
  uploadedById String?
  isPublic     Boolean  @default(true) // visible par le client
  createdAt    DateTime @default(now())

  @@index([portalId])
  @@index([projectId])
  @@index([category])
}

// Réunions avec le client
model ClientMeeting {
  id                 String       @id @default(cuid())
  portalId           String
  portal             ClientPortal @relation(fields: [portalId], references: [id], onDelete: Cascade)
  projectId          String?
  title              String
  description        String?      @db.Text
  meetingDate        DateTime
  startTime          DateTime // Alias pour meetingDate (pour compatibilité)
  endTime            DateTime? // Calculé à partir de duration
  duration           Int          @default(30) // en minutes
  timezone           String       @default("America/Montreal")
  location           String? // URL de visio ou lieu physique
  meetingType        String       @default("video") // video, phone, in_person
  status             String       @default("scheduled") // scheduled, confirmed, completed, cancelled, rescheduled
  isCancelled        Boolean      @default(false)
  cancelledAt        DateTime?
  cancellationReason String?      @db.Text

  // Participants
  attendees         String? @db.Text // JSON array of attendees
  clientAttendees   String? @db.Text // JSON array de noms/emails clients
  employeeAttendees String? @db.Text // JSON array d'employee IDs

  // Intégration calendrier
  googleCalendarEventId  String? // ID de l'événement Google Calendar
  outlookCalendarEventId String? // ID de l'événement Outlook
  calendarSyncStatus     String  @default("pending") // pending, synced, failed
  calendarSyncError      String? @db.Text

  // Rappels
  reminderSent    Boolean   @default(false)
  reminderSentAt  DateTime?
  reminderMinutes Int[]     @default([1440, 60]) // 24h et 1h avant

  // Notes de réunion
  notes         String?   @db.Text
  notesShared   Boolean   @default(false)
  notesSharedAt DateTime?
  recordingUrl  String?
  agendaItems   String?   @db.Text // JSON array
  actionItems   String?   @db.Text // JSON array
  createdBy     String? // "client" ou employee ID
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  meetingNotes MeetingNote[]

  @@index([portalId])
  @@index([projectId])
  @@index([meetingDate])
  @@index([startTime])
  @@index([status])
  @@index([googleCalendarEventId])
  @@index([outlookCalendarEventId])
}

// Notes de réunion partagées
model MeetingNote {
  id        String        @id @default(cuid())
  meetingId String
  meeting   ClientMeeting @relation(fields: [meetingId], references: [id], onDelete: Cascade)

  content    String  @db.Text
  authorType String // client, employee
  authorName String
  authorId   String? // employee ID si employee

  isShared  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([meetingId])
  @@index([createdAt])
}

// Disponibilités pour réservation
model MeetingAvailability {
  id          String  @id @default(cuid())
  employeeId  String? // Si null, disponibilité générale
  dayOfWeek   Int // 0 = dimanche, 6 = samedi
  startTime   String // Format HH:mm (ex: "09:00")
  endTime     String // Format HH:mm (ex: "17:00")
  timezone    String  @default("America/Montreal")
  isAvailable Boolean @default(true)

  // Exceptions (dates spécifiques)
  exceptionDates String? @db.Text // JSON array de dates (YYYY-MM-DD)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([employeeId])
  @@index([dayOfWeek])
}

// Suivi du budget projet pour le client
model ProjectBudgetTracking {
  id          String   @id @default(cuid())
  portalId    String
  projectId   String?
  totalBudget Float
  spentAmount Float    @default(0)
  currency    String   @default("CAD")
  lastUpdated DateTime @default(now())
  breakdown   String?  @db.Text // JSON breakdown by category
  invoices    String?  @db.Text // JSON array of invoice references
  notes       String?  @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([portalId])
  @@index([projectId])
}

// Timeline/Étapes de projet visible par le client
model ClientProjectMilestone {
  id          String    @id @default(cuid())
  portalId    String
  projectId   String?
  title       String
  description String?   @db.Text
  phase       String? // discovery, design, development, testing, launch
  status      String    @default("upcoming") // upcoming, in_progress, completed, delayed
  dueDate     DateTime?
  completedAt DateTime?
  order       Int       @default(0)
  isVisible   Boolean   @default(true) // visible par le client
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  @@index([portalId])
  @@index([projectId])
  @@index([status])
  @@index([order])
}

// Commentaires sur les fichiers/livrables
model ClientFileComment {
  id            String   @id @default(cuid())
  fileId        String? // ClientFile id
  deliverableId String? // ClientDeliverable id
  portalId      String
  content       String   @db.Text
  authorType    String // client, employee
  authorName    String
  authorId      String?
  positionX     Float? // Position du commentaire sur l'image/document
  positionY     Float?
  pageNumber    Int? // Pour les PDFs
  isResolved    Boolean  @default(false)
  createdAt     DateTime @default(now())

  @@index([fileId])
  @@index([deliverableId])
  @@index([portalId])
}

// Demandes de vacances
model VacationRequest {
  id             String    @id @default(cuid())
  employeeId     String
  employee       Employee  @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  type           String // vacation, sick, personal, unpaid, other
  startDate      DateTime
  endDate        DateTime
  totalDays      Float // Nombre de jours demandés
  reason         String?   @db.Text
  status         String    @default("pending") // pending, approved, rejected, cancelled
  reviewedBy     String? // ID de l'admin qui a traité la demande
  reviewedByName String? // Nom de l'admin
  reviewedAt     DateTime?
  reviewComment  String?   @db.Text
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@index([employeeId])
  @@index([status])
  @@index([startDate])
  @@index([endDate])
}

// Solde de vacances par employé
model VacationBalance {
  id              String   @id @default(cuid())
  employeeId      String   @unique
  employee        Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)
  year            Int      @default(2025)
  totalDays       Float    @default(20) // Jours alloués par an
  usedDays        Float    @default(0) // Jours utilisés
  pendingDays     Float    @default(0) // Jours en attente d'approbation
  carriedOverDays Float    @default(0) // Jours reportés de l'année précédente
  sickDaysUsed    Float    @default(0) // Jours maladie utilisés
  sickDaysAllowed Float    @default(5) // Jours maladie alloués
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@index([employeeId])
  @@index([year])
}

// ==================== MODULE FACTURATION ====================

// Factures
model Invoice {
  id            String  @id @default(cuid())
  invoiceNumber String  @unique // Format: INV-2024-0001
  quoteId       String? // Référence au devis si converti
  projectId     String?

  // Informations client
  clientName    String
  clientEmail   String?
  clientCompany String?
  clientAddress String? @db.Text
  clientPhone   String?

  // Informations facture
  title       String
  description String?  @db.Text
  issueDate   DateTime @default(now())
  dueDate     DateTime

  // Statut
  status String @default("draft") // draft, sent, viewed, paid, partial, overdue, cancelled

  // Montants
  subtotal        Float  @default(0)
  discountPercent Float  @default(0)
  discountAmount  Float  @default(0)
  taxRate         Float  @default(0.14975) // TPS 5% + TVQ 9.975%
  taxAmount       Float  @default(0)
  total           Float  @default(0)
  amountPaid      Float  @default(0)
  amountDue       Float  @default(0)
  currency        String @default("CAD")

  // Métadonnées
  notes      String? @db.Text
  terms      String? @db.Text
  footerNote String? @db.Text

  // Suivi
  sentAt         DateTime?
  viewedAt       DateTime?
  paidAt         DateTime?
  lastReminderAt DateTime?
  reminderCount  Int       @default(0)

  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  items     InvoiceItem[]
  payments  Payment[]
  reminders PaymentReminder[]

  @@index([projectId])
  @@index([status])
  @@index([dueDate])
  @@index([clientEmail])
}

// Lignes de facture
model InvoiceItem {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  description String
  quantity    Float  @default(1)
  unitPrice   Float
  unit        String @default("unité") // heure, jour, unité, forfait
  amount      Float // quantity * unitPrice

  // Optionnel: lien avec projet/phase
  projectId String?
  phaseId   String?

  sortOrder Int      @default(0)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceId])
}

// Paiements
model Payment {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  amount        Float
  paymentDate   DateTime @default(now())
  paymentMethod String   @default("virement") // virement, cheque, carte, especes, paypal, stripe
  reference     String? // Numéro de transaction/chèque
  notes         String?  @db.Text

  recordedBy String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([invoiceId])
  @@index([paymentDate])
}

// Relances de paiement
model PaymentReminder {
  id        String  @id @default(cuid())
  invoiceId String
  invoice   Invoice @relation(fields: [invoiceId], references: [id], onDelete: Cascade)

  type       String    @default("email") // email, phone, letter
  sentAt     DateTime  @default(now())
  sentBy     String?
  message    String?   @db.Text
  response   String?   @db.Text
  responseAt DateTime?

  // Niveau de relance
  level Int @default(1) // 1: rappel amical, 2: relance ferme, 3: mise en demeure

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([invoiceId])
  @@index([sentAt])
}

// ============================================
// SYSTÈME DE RECOMMANDATIONS
// ============================================

model Recommendation {
  id          String @id @default(cuid())
  title       String
  description String @db.Text
  category    String @default("general") // general, feature, bug, ux, performance
  priority    String @default("medium") // low, medium, high, critical
  status      String @default("pending") // pending, reviewing, planned, in_progress, completed, rejected

  // Source de la recommandation
  sourceType     String // employee, client
  employeeId     String?
  employee       Employee?     @relation(fields: [employeeId], references: [id])
  clientPortalId String?
  clientPortal   ClientPortal? @relation(fields: [clientPortalId], references: [id])

  // Réponse de l'équipe
  adminResponse String?   @db.Text
  respondedAt   DateTime?
  respondedBy   String?

  // Votes
  votes     RecommendationVote[]
  voteCount Int                  @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([sourceType])
  @@index([employeeId])
  @@index([clientPortalId])
}

model RecommendationVote {
  id               String         @id @default(cuid())
  recommendationId String
  recommendation   Recommendation @relation(fields: [recommendationId], references: [id], onDelete: Cascade)

  // Qui a voté
  voterType      String // employee, client
  employeeId     String?
  clientPortalId String?

  createdAt DateTime @default(now())

  @@unique([recommendationId, employeeId])
  @@unique([recommendationId, clientPortalId])
  @@index([recommendationId])
}

// ============================================
// SYSTÈME DE SONDAGES
// ============================================

model Survey {
  id          String  @id @default(cuid())
  title       String
  description String? @db.Text
  status      String  @default("draft") // draft, active, closed

  // Période de validité
  startDate DateTime?
  endDate   DateTime?

  // Cible
  targetType       String  @default("all") // all, department, specific
  targetDepartment String?

  // Anonymat
  isAnonymous Boolean @default(false)

  // Questions et réponses
  questions SurveyQuestion[]
  responses SurveyResponse[]

  createdBy String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([startDate])
  @@index([endDate])
}

model SurveyQuestion {
  id       String @id @default(cuid())
  surveyId String
  survey   Survey @relation(fields: [surveyId], references: [id], onDelete: Cascade)

  questionText String @db.Text
  questionType String // text, single_choice, multiple_choice, scale, rating

  // Options pour les questions à choix
  options String? @db.Text // JSON array des options

  // Configuration
  isRequired Boolean @default(true)
  order      Int     @default(0)

  // Pour les échelles
  scaleMin      Int?    @default(1)
  scaleMax      Int?    @default(5)
  scaleMinLabel String?
  scaleMaxLabel String?

  answers SurveyAnswer[]

  createdAt DateTime @default(now())

  @@index([surveyId])
}

model SurveyResponse {
  id       String @id @default(cuid())
  surveyId String
  survey   Survey @relation(fields: [surveyId], references: [id], onDelete: Cascade)

  // Répondant (null si anonyme)
  employeeId String?
  employee   Employee? @relation(fields: [employeeId], references: [id])

  // Réponses aux questions
  answers SurveyAnswer[]

  completedAt DateTime @default(now())

  @@index([surveyId])
  @@index([employeeId])
}

model SurveyAnswer {
  id         String         @id @default(cuid())
  responseId String
  response   SurveyResponse @relation(fields: [responseId], references: [id], onDelete: Cascade)

  questionId String
  question   SurveyQuestion @relation(fields: [questionId], references: [id], onDelete: Cascade)

  // Réponse
  textAnswer    String? @db.Text
  choiceAnswer  String? // Pour single_choice
  choicesAnswer String? // JSON array pour multiple_choice
  scaleAnswer   Int? // Pour scale et rating

  createdAt DateTime @default(now())

  @@index([responseId])
  @@index([questionId])
}

model CommunicationContextDocument {
  id       String              @id @default(cuid())
  clientId String
  client   CommunicationClient @relation(fields: [clientId], references: [id], onDelete: Cascade)

  // Document metadata
  title        String
  description  String? @db.Text
  documentType String // brand_guide, company_profile, product_info, audience_data, etc.

  // File storage
  fileUrl  String @db.Text // URL du fichier stocké (S3)
  fileKey  String @db.Text // Clé S3 pour accès/suppression
  fileName String
  fileSize Int // Taille en bytes
  mimeType String // application/pdf, text/plain, etc.

  // Content extraction (pour le contexte IA)
  extractedText String? @db.Text // Texte extrait du document pour Leo

  // Metadata
  uploadedBy String // Email de la personne qui a uploadé
  uploadedAt DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@index([clientId])
  @@index([documentType])
}

model MenuItem {
  id          String  @id @default(cuid())
  key         String  @unique // dashboard, employees, projects, etc.
  label       String
  icon        String? // lucide-react icon name
  path        String?
  description String? @db.Text
  category    String? // main, tools, admin, etc.
  order       Int     @default(0)
  isActive    Boolean @default(true)

  permissions MenuPermission[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([category])
}

model MenuPermission {
  id     String @id @default(cuid())
  userId String
  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)

  menuItemId String
  menuItem   MenuItem @relation(fields: [menuItemId], references: [id], onDelete: Cascade)

  hasAccess Boolean @default(true)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, menuItemId])
  @@index([userId])
  @@index([menuItemId])
}

// Personal Tasks - Tâches personnelles des employés
model PersonalTask {
  id         String   @id @default(cuid())
  employeeId String
  employee   Employee @relation(fields: [employeeId], references: [id], onDelete: Cascade)

  title       String
  description String?   @db.Text
  status      String    @default("todo") // todo, in_progress, done
  priority    String    @default("medium") // low, medium, high
  dueDate     DateTime?

  // Sections (comme dans Asana)
  section String? @default("My Tasks") // My Tasks, In Progress, Done, etc.

  // Ordre dans la section
  order Int @default(0)

  // Métadonnées
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt
  completedAt DateTime?

  @@index([employeeId])
  @@index([status])
  @@index([priority])
  @@index([dueDate])
  @@index([section])
}

// ==================== MODULE APPROBATIONS CLIENT ====================

// Workflow d'approbation pour les livrables
model ApprovalWorkflow {
  id            String            @id @default(cuid())
  deliverableId String            @unique
  deliverable   ClientDeliverable @relation(fields: [deliverableId], references: [id], onDelete: Cascade)
  workflowType  String            @default("simple") // simple, multi_step, parallel
  currentStep   Int               @default(1)
  status        String            @default("pending") // pending, in_progress, approved, rejected, cancelled
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  steps      ApprovalStep[]
  signatures ApprovalSignature[]
  history    ApprovalHistory[]

  @@index([deliverableId])
  @@index([status])
}

// Étapes du workflow d'approbation
model ApprovalStep {
  id           String           @id @default(cuid())
  workflowId   String
  workflow     ApprovalWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  stepNumber   Int // Ordre de l'étape (1, 2, 3...)
  name         String // Nom de l'étape (ex: "Révision initiale", "Approbation finale")
  description  String?          @db.Text
  approverType String // client, employee, specific_user
  approverId   String? // ID spécifique si approverType = specific_user
  approverName String? // Nom de l'approbateur
  isRequired   Boolean          @default(true)
  status       String           @default("pending") // pending, approved, rejected, skipped
  approvedAt   DateTime?
  approvedBy   String?
  comments     String?          @db.Text
  createdAt    DateTime         @default(now())
  updatedAt    DateTime         @updatedAt

  @@unique([workflowId, stepNumber])
  @@index([workflowId])
  @@index([stepNumber])
}

// Signatures électroniques
model ApprovalSignature {
  id              String           @id @default(cuid())
  workflowId      String
  workflow        ApprovalWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  stepId          String? // Optionnel : signature liée à une étape spécifique
  signerType      String // client, employee
  signerName      String
  signerEmail     String?
  signatureData   String           @db.Text // Données de la signature (SVG, image base64, etc.)
  signatureMethod String           @default("draw") // draw, type, upload
  ipAddress       String?
  userAgent       String?          @db.Text
  signedAt        DateTime         @default(now())

  @@index([workflowId])
  @@index([stepId])
}

// Historique des approbations
model ApprovalHistory {
  id         String           @id @default(cuid())
  workflowId String
  workflow   ApprovalWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  stepId     String? // Optionnel : action sur une étape spécifique
  action     String // approve, reject, request_revision, comment, signature_added
  actorType  String // client, employee
  actorName  String
  actorId    String?
  comments   String?          @db.Text
  metadata   String?          @db.Text // JSON pour données supplémentaires
  createdAt  DateTime         @default(now())

  @@index([workflowId])
  @@index([createdAt])
}

// Versions de livrables avec approbations
model DeliverableVersion {
  id            String            @id @default(cuid())
  deliverableId String
  deliverable   ClientDeliverable @relation(fields: [deliverableId], references: [id], onDelete: Cascade)
  versionNumber Int // 1, 2, 3...
  fileUrl       String?
  thumbnailUrl  String?
  changeLog     String?           @db.Text // Description des changements
  status        String            @default("draft") // draft, submitted, approved, rejected
  submittedAt   DateTime?
  approvedAt    DateTime?
  approvedBy    String?
  workflowId    String? // Workflow d'approbation pour cette version
  createdAt     DateTime          @default(now())

  // Relations pour le nouveau système
  comments      VersionComment[]
  qualityChecks QualityCheck[]
  revisionWorkflow RevisionWorkflow?

  @@unique([deliverableId, versionNumber])
  @@index([deliverableId])
  @@index([versionNumber])
}

// Commentaires sur les versions de fichiers
model VersionComment {
  id            String            @id @default(cuid())
  versionId     String
  version       DeliverableVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)
  commentType   String            @default("general") // general, revision_request, approval_note, quality_issue
  content       String            @db.Text
  authorType    String            // client, employee
  authorName    String
  authorId      String?           // employee ID si employee
  fileReference String?           // Référence à une partie spécifique du fichier (coordonnées, page, etc.)
  isResolved    Boolean           @default(false)
  resolvedAt    DateTime?
  resolvedBy    String?
  parentCommentId String?         // Pour les réponses aux commentaires
  parentComment VersionComment?   @relation("CommentReplies", fields: [parentCommentId], references: [id])
  replies       VersionComment[]  @relation("CommentReplies")
  attachments   String?           @db.Text // JSON array de fichiers joints
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([versionId])
  @@index([parentCommentId])
  @@index([createdAt])
}

// Workflow de révision structuré
model RevisionWorkflow {
  id            String            @id @default(cuid())
  versionId     String            @unique
  version       DeliverableVersion @relation(fields: [versionId], references: [id], onDelete: Cascade)
  workflowType  String            @default("structured") // structured, simple, parallel
  currentLevel  Int               @default(1) // Niveau actuel dans l'approbation multi-niveaux
  status        String            @default("draft") // draft, in_review, revision_requested, approved, rejected
  revisionRound Int               @default(1) // Numéro de round de révision
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  levels        ApprovalLevel[]
  revisions     RevisionRound[]
  checklist     QualityChecklist?

  @@index([versionId])
  @@index([status])
}

// Niveaux d'approbation multi-niveaux
model ApprovalLevel {
  id              String           @id @default(cuid())
  workflowId      String
  workflow        RevisionWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  levelNumber     Int              // 1, 2, 3... (ordre hiérarchique)
  name            String           // Ex: "Révision initiale", "Approbation manager", "Approbation finale"
  description     String?          @db.Text
  approverType    String           // client, employee, manager, director, specific_user
  approverId      String?          // ID spécifique si approverType = specific_user
  approverName    String?
  approverEmail   String?
  isRequired      Boolean          @default(true)
  canDelegate     Boolean          @default(false) // Peut déléguer à quelqu'un d'autre
  minApprovers    Int              @default(1) // Nombre minimum d'approbateurs requis
  maxApprovers    Int              @default(1) // Nombre maximum d'approbateurs
  status          String           @default("pending") // pending, in_progress, approved, rejected, skipped
  startedAt       DateTime?
  completedAt     DateTime?
  deadline        DateTime?        // Date limite pour cette approbation
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  approvers       LevelApprover[]
  comments        LevelComment[]

  @@unique([workflowId, levelNumber])
  @@index([workflowId])
  @@index([levelNumber])
}

// Approbateurs pour un niveau spécifique
model LevelApprover {
  id          String         @id @default(cuid())
  levelId     String
  level       ApprovalLevel  @relation(fields: [levelId], references: [id], onDelete: Cascade)
  approverType String         // client, employee
  approverId  String?        // employee ID si employee
  approverName String
  approverEmail String?
  status      String         @default("pending") // pending, approved, rejected, delegated
  delegatedTo String?        // Nom de la personne à qui c'est délégué
  comments    String?        @db.Text
  approvedAt  DateTime?
  rejectedAt  DateTime?
  createdAt   DateTime       @default(now())
  updatedAt   DateTime        @updatedAt

  @@index([levelId])
  @@index([status])
}

// Commentaires spécifiques à un niveau d'approbation
model LevelComment {
  id          String         @id @default(cuid())
  levelId     String
  level       ApprovalLevel  @relation(fields: [levelId], references: [id], onDelete: Cascade)
  commentType String         @default("feedback") // feedback, revision_request, approval_note, question
  content     String         @db.Text
  authorType  String         // client, employee
  authorName  String
  authorId    String?
  isInternal  Boolean        @default(false) // Commentaire interne (non visible par le client)
  createdAt   DateTime       @default(now())

  @@index([levelId])
  @@index([createdAt])
}

// Rounds de révision
model RevisionRound {
  id            String           @id @default(cuid())
  workflowId    String
  workflow      RevisionWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  roundNumber   Int              // 1, 2, 3...
  status        String           @default("in_progress") // in_progress, completed, cancelled
  requestedBy   String           // Nom de la personne qui a demandé la révision
  requestedById String?          // Employee ID
  reason        String?          @db.Text // Raison de la révision
  requestedChanges String?       @db.Text // Changements demandés
  completedAt   DateTime?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  @@index([workflowId])
  @@index([roundNumber])
}

// Checklist qualité
model QualityChecklist {
  id            String           @id @default(cuid())
  workflowId    String           @unique
  workflow      RevisionWorkflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  templateId    String?          // Référence à un template de checklist
  status        String           @default("pending") // pending, in_progress, passed, failed
  overallScore  Float?           // Score global (0-100)
  passedAt      DateTime?
  failedAt      DateTime?
  reviewedBy    String?
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  items         QualityCheck[]

  @@index([workflowId])
  @@index([status])
}

// Items de la checklist qualité
model QualityCheck {
  id              String           @id @default(cuid())
  checklistId     String?
  checklist       QualityChecklist? @relation(fields: [checklistId], references: [id], onDelete: Cascade)
  versionId       String?         // Optionnel : check directement sur une version
  version         DeliverableVersion? @relation(fields: [versionId], references: [id], onDelete: Cascade)
  category        String           // design, content, technical, accessibility, performance, legal, other
  title            String
  description      String?         @db.Text
  criteria         String          @db.Text // Critères de vérification
  isRequired       Boolean         @default(true)
  status           String          @default("pending") // pending, passed, failed, n_a
  checkedBy        String?         // Nom de la personne qui a vérifié
  checkedById      String?         // Employee ID
  checkedAt        DateTime?
  notes            String?         @db.Text
  evidence         String?         @db.Text // JSON array de preuves (screenshots, fichiers, etc.)
  score            Float?          // Score pour cet item (0-100)
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  @@index([checklistId])
  @@index([versionId])
  @@index([category])
  @@index([status])
}

// ==================== MODULE GESTION CONTRATS ====================

// Fournisseurs et sous-traitants
model Supplier {
  id          String   @id @default(cuid())
  name        String
  type        String // supplier, subcontractor, partner
  contactName String?
  email       String?
  phone       String?
  address     String?  @db.Text
  taxId       String? // Numéro de TVA/SIRET
  website     String?
  notes       String?  @db.Text
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  contracts Contract[]

  @@index([type])
  @@index([isActive])
}

// Templates de contrats
model ContractTemplate {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  category    String // client, supplier, subcontractor, nda, service, other
  content     String   @db.Text // Contenu du template (HTML/Markdown)
  variables   String?  @db.Text // JSON array des variables disponibles
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
  createdBy   String? // Employee ID

  contracts Contract[]

  @@index([category])
  @@index([isActive])
}

// Contrats
model Contract {
  id             String            @id @default(cuid())
  contractNumber String            @unique // Format: CONTRACT-2024-0001
  templateId     String?
  template       ContractTemplate? @relation(fields: [templateId], references: [id])

  // Parties
  companyId  String? // Si contrat client (via Company)
  company    Company?  @relation(fields: [companyId], references: [id])
  supplierId String? // Si contrat fournisseur/sous-traitant
  supplier   Supplier? @relation(fields: [supplierId], references: [id])

  // Informations contrat
  title       String
  description String? @db.Text
  category    String // client, supplier, subcontractor, nda, service, other
  type        String? // service, purchase, lease, employment, other

  // Dates
  startDate         DateTime?
  endDate           DateTime?
  renewalDate       DateTime? // Date de renouvellement automatique
  signatureDeadline DateTime? // Date limite pour signature

  // Statut
  status String @default("draft") // draft, pending_signature, active, expired, terminated, cancelled

  // Montants
  totalAmount  Float?
  currency     String  @default("CAD")
  paymentTerms String? @db.Text

  // Contenu
  content String  @db.Text // Contenu final du contrat
  terms   String? @db.Text // Conditions générales

  // Fichiers
  documentUrl String? // PDF du contrat
  attachments String? @db.Text // JSON array de fichiers

  // Signatures
  requiresSignature Boolean   @default(true)
  signedByClient    Boolean   @default(false)
  signedBySupplier  Boolean   @default(false)
  signedByAgency    Boolean   @default(false)
  clientSignedAt    DateTime?
  supplierSignedAt  DateTime?
  agencySignedAt    DateTime?

  // Notifications
  renewalReminderDays Int[]     @default([90, 60, 30]) // Jours avant échéance pour rappel
  lastReminderSent    DateTime?

  // Métadonnées
  notes     String?  @db.Text
  tags      String?  @db.Text // JSON array de tags
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  createdBy String? // Employee ID

  signatures ContractSignature[]
  renewals   ContractRenewal[]
  amendments ContractAmendment[]

  @@index([contractNumber])
  @@index([companyId])
  @@index([supplierId])
  @@index([status])
  @@index([category])
  @@index([endDate])
  @@index([renewalDate])
}

// Signatures électroniques des contrats
model ContractSignature {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  signerType  String // client, supplier, agency, employee
  signerId    String? // ID du signataire (clientId, supplierId, employeeId)
  signerName  String
  signerEmail String?
  signerTitle String? // Titre/fonction du signataire

  signatureData   String  @db.Text // Données de la signature (SVG, image base64)
  signatureMethod String  @default("draw") // draw, type, upload
  ipAddress       String?
  userAgent       String? @db.Text

  signedAt DateTime @default(now())

  @@index([contractId])
  @@index([signerType])
}

// Renouvellements de contrats
model ContractRenewal {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  renewalDate DateTime
  newEndDate  DateTime
  changes     String?   @db.Text // Changements apportés
  status      String    @default("pending") // pending, approved, rejected
  approvedBy  String? // Employee ID
  approvedAt  DateTime?
  notes       String?   @db.Text

  createdAt DateTime @default(now())
  createdBy String? // Employee ID

  @@index([contractId])
  @@index([renewalDate])
  @@index([status])
}

// Amendements aux contrats
model ContractAmendment {
  id         String   @id @default(cuid())
  contractId String
  contract   Contract @relation(fields: [contractId], references: [id], onDelete: Cascade)

  amendmentNumber String // Format: AMENDMENT-1, AMENDMENT-2...
  title           String
  description     String @db.Text
  changes         String @db.Text // Détails des changements

  effectiveDate     DateTime
  requiresSignature Boolean  @default(true)
  status            String   @default("draft") // draft, pending_signature, approved, rejected

  documentUrl String? // PDF de l'amendement

  createdAt DateTime @default(now())
  createdBy String? // Employee ID

  signatures ContractAmendmentSignature[]

  @@index([contractId])
  @@index([effectiveDate])
  @@index([status])
}

// Signatures des amendements
model ContractAmendmentSignature {
  id          String            @id @default(cuid())
  amendmentId String
  amendment   ContractAmendment @relation(fields: [amendmentId], references: [id], onDelete: Cascade)

  signerType      String // client, supplier, agency
  signerName      String
  signerEmail     String?
  signatureData   String   @db.Text
  signatureMethod String   @default("draw")
  ipAddress       String?
  userAgent       String?  @db.Text
  signedAt        DateTime @default(now())

  @@index([amendmentId])
}

// Clés API pour l'accès externe
model ApiKey {
  id              String   @id @default(cuid())
  name            String   // Nom descriptif de la clé (ex: "Site web principal")
  key             String   @unique // La clé API elle-même (hashée)
  keyPrefix       String   // Préfixe visible (ex: "nk_abc123...")
  isActive        Boolean  @default(true)
  lastUsedAt      DateTime? // Dernière utilisation
  expiresAt       DateTime? // Date d'expiration (null = jamais)
  allowedIps      String?  @db.Text // JSON array d'IPs autorisées (null = toutes)
  allowedEndpoints String? @db.Text // JSON array d'endpoints autorisés (null = tous) ex: ["/api/testimonials"]
  rateLimit       Int      @default(1000) // Requêtes par heure
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  createdBy       String? // Employee ID qui a créé la clé

  @@index([key])
  @@index([isActive])
  @@index([expiresAt])
}